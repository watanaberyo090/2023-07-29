<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <style>
      body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <div id="timeContainer" style="position: absolute; top: 10px; right: 10px; font-size: 24px; color: white;"></div>
    <div id="score" style="position: absolute; top: 10px; left: 10px; font-size: 24px; color: white;"></div>
    <!-- three.jsのcanvas要素を配置するための場所 -->
    <div id="canvas-container"></div>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/",
          "webxr-polyfill": "https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.module.js"
        }
      }
    </script>

    <script type="module">
      // three.jsの読み込み
      import * as THREE from "three";
      // WebVRの判定、遷移ボタンのスクリプト
      import { VRButton } from "three/addons/webxr/VRButton.js";

      // WebXRのポリフィルを読み込み
      import WebXRPolyfill from "webxr-polyfill";
      //コントローラ
      import { XRControllerModelFactory } from 'https://unpkg.com/three@0.150.1/examples/jsm/webxr/XRControllerModelFactory.js';
      import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
      import { FontLoader } from 'three/addons/loaders/FontLoader.js';
      //スコア変数
      let scores=0;
      //コントローラー
      let controller1, controller2;
      let controllerGrip1, controllerGrip2;

      // 秒数を表示するテキスト要素を取得
      const timeContainer = document.getElementById("timeContainer");
      const container = document.createElement( 'div' );
		 document.body.appendChild( container );
      //時間60秒になったら停止するための変数
      let shouldStopRendering = false;

      // WebXRのポリフィルを有効にする
      const polyfill = new WebXRPolyfill();

      // サイズを指定
      const width = window.innerWidth;
      const height = window.innerHeight;
      
    
      // レンダラーを作成
      let renderer = new THREE.WebGLRenderer({
        antialias: true,
      });
      renderer.setSize(width, height);
      renderer.setPixelRatio( window.devicePixelRatio );
     // renderer.outputEncoding = THREE.sRGBEncoding;

      // レンダラーのWebVR設定を有効にする
      console.log(renderer);
      renderer.xr.enabled = true;

      document.body.appendChild(renderer.domElement);

      // WebVRの開始ボタンをDOMに追加
      document.body.appendChild(VRButton.createButton(renderer));

      // シーンを作成
      const scene = new THREE.Scene();

      // カメラを作成
      const camera = new THREE.PerspectiveCamera(90, width / height);
      

      // カメラ用コンテナを作成
      const cameraContainer = new THREE.Object3D();
      cameraContainer.add(camera);
      scene.add(cameraContainer);
      cameraContainer.position.y = 0;
      cameraContainer.position.z = 0;
      //バックグラウンド背景
      const loader = new THREE.TextureLoader();
      const bgTexture = loader.load('background.jpg');
      const sphereGeometry = new THREE.SphereGeometry(10, 10, 10);
      const material = new THREE.MeshBasicMaterial({ map: bgTexture, side: THREE.BackSide });
      const sphere = new THREE.Mesh(sphereGeometry, material);
      scene.add(sphere);
// スコアを表示するテキストオブジェクト
// フォントローダー
const fontLoader = new FontLoader();
let textMesh;
// フォントを読み込む
const font = await fontLoader.loadAsync("Rounded Mplus 1c Black_Regular.json");
function score(){
  if (textMesh) {
    scene.remove(textMesh);
  }
textMesh = new THREE.Mesh(
  new TextGeometry(`score:${scores}`, {
    font: font, // フォントを指定 (FontLoaderで読み込んだjson形式のフォント)
    size: 10,   // 文字のサイズを指定
    height: 1,  // 文字の厚さを指定
  }),
  new THREE.MeshBasicMaterial({
    color: `#ccc`, // 文字の色
  })
);
textMesh.position.set(0, 2, -1);   // Meshの位置を設定
textMesh.scale.set(0.01, 0.01, 0.01); // Meshの拡大縮小設定
scores++;
scene.add(textMesh);
}
score();
// 毎フレームごとに秒数を更新して表示
function updateTime2() {
const seconds = Math.floor(time / 60); // 秒数を計算
timeContainer.textContent="seconds:"+seconds;
if(seconds>=60){
shouldStopRendering = true;
}
}

    //   光源を作成
      {
        const spotLight = new THREE.SpotLight(
          0xffffff,
          4,
          2000,
          Math.PI / 5,
          0.2,
          1.5
        );
        spotLight.position.set(500, 900, 500);
        scene.add(spotLight);

        const ambientLight = new THREE.AmbientLight(0x333333);
        scene.add(ambientLight);
      }
     // 地面を作成
     const gridHelper = new THREE.GridHelper(10,7,0xffffff,0xffffff);
      scene.add(gridHelper);
		const pg = new THREE.PlaneGeometry( 10, 10);
		const pm = new THREE.MeshBasicMaterial( {color: 0x808080, side: THREE.DoubleSide} );
		const plane = new THREE.Mesh(pg, pm);　plane.rotation.x =-Math.PI/2;//plane.position.y = -50;
		scene.add( plane );
		scene.add( new THREE.HemisphereLight( 0x888877, 0x777788 ) );
      
      const boxList = [];
      // 立方体を作成
      {
        // 立方体のジオメトリを作成
        const geometry = new THREE.BoxGeometry(0.45, 0.45, 0.45);
        // 立方体を複数作成しランダムに配置
        const num = 60;
        loop: for (let i = 0; i < num; i++) {
          const px = (Math.round((Math.random() - 0.5) * 19) * 50 + 25)/100;
          const py = (Math.round((Math.random() - 0.5) * 19) * 50 + 250)/100;
          const pz = (Math.round((Math.random() - 0.5) * 19) *  50)/100;
          for (let j = 0; j < i; j++) {
            const box2 = boxList[j];
            if (box2.position.x === px && box2.position.z === pz) {
              i -= 1;
              continue loop;
            }
          }
          // 立方体のマテリアルを作成
          const material = new THREE.MeshStandardMaterial({
            color: 0x1000000 * Math.random(),
            roughness: 0.1,
            metalness: 0.5,
          });
          const box = new THREE.Mesh(geometry, material);
          box.position.x = px;
          box.position.y = py;
          box.position.z = pz;
          scene.add(box);
          boxList.push(box);
        }
      }
      // 立方体の作成
  const cube = createCube();
  cube.position.set( -5, 0, -5);
  scene.add(cube);
  let time = 0;

// 毎フレーム時に実行されるループイベント
function tick() {
  time += 1;

  // 立方体を動かす
  const length = boxList.length;
  for (let i = 0; i < length; i++) {
if (boxList[i].position.z >5) {
  // box消滅させる
  scene.remove(boxList[i]);
  //消滅させたboxを表示
  boxList[i].position.z = -5;
  scene.add(boxList[i]);
} else {
  // ランダムな動き
  boxList[i].position.z +=0.02;
  boxList[i].position.y =
  (125 + 100 * Math.cos(time * 0.0005 * i + i / 10))/100;
}
}

  // // レンダリング
   renderer.render(scene, camera);
   
}

  
// リサイズ処理
window.addEventListener("resize", onResize);
function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(window.innerWidth, window.innerHeight);
}
    
  /* ----コントローラー設定----- */
  
  // コントローラーイベントの設定
  function onSelectStart() {
    this.userData.isSelecting = true;
  }
  function onSelectEnd() {
    this.userData.isSelecting = false;
  }	

  //コントローラー取得
  controller1 = renderer.xr.getController( 0 );
  controller1.addEventListener( 'selectstart', onSelectStart );
  controller1.addEventListener( 'selectend', onSelectEnd );
  scene.add( controller1 );
  controller2 = renderer.xr.getController( 1 );
  controller2.addEventListener( 'selectstart', onSelectStart );
  controller2.addEventListener( 'selectend', onSelectEnd );
  scene.add( controller2 );

  //コントローラーモデルを取得
  const controllerModelFactory = new XRControllerModelFactory();
  controllerGrip1 = renderer.xr.getControllerGrip(0);
  controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
  scene.add( controllerGrip1 );
  controllerGrip2 = renderer.xr.getControllerGrip(1);
  controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
  scene.add( controllerGrip2 );
  //コントローラーから出る光線の作成				
  const geo = new THREE.BufferGeometry().setFromPoints( [ new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 0, -1 )]);
  const line = new THREE.Line( geo );
  line.name = 'line';
  line.scale.z = 5;
  controller1.add( line.clone() );
  controller2.add( line.clone() );
  
  //機能
  // レイキャスターを作成
const raycaster = new THREE.Raycaster();

// 光線の方向ベクトルを格納するVector3
const rayDirection = new THREE.Vector3();

// レイキャスターの原点（コントローラーの位置）を格納するVector3
const rayOrigin = new THREE.Vector3();
  function handleController(controller) {
  const userData = controller.userData;

  // コントローラーのボタンが押された場合
  if (userData.isSelecting === true) {
    // コントローラーの位置をrayOriginにセット
    rayOrigin.setFromMatrixPosition(controller.matrixWorld);

    // コントローラーの前方に向けて光線を伸ばす
    controller.getWorldDirection(rayDirection);
    rayDirection.normalize().multiplyScalar(2);
    rayDirection.negate(); // 光線の方向を反転する
    raycaster.set(rayOrigin, rayDirection);
    // 光線とboxListとの交差をチェック

    for(let i=0;i<boxList.length;i++){
    const intersects = raycaster.intersectObject(boxList[i]);
    // 交差した立方体を削除
    if (intersects.length > 0) {
      console.log("ログに出力したい文字列");
      score();
      scene.remove(boxList[i]);
      boxList.splice(i, 1); // i 番目の要素を削除
      i--; // i の値を 1 減らす
    }
  }
  }
  const line = controller.getObjectByName('line');
    if (line) {
      line.scale.z = rayDirection.length(); // 光線の長さを更新
    }
}
	// function handleController( controller ) {
	// 	const userData = controller.userData;
	// 	if ( userData.isSelecting === true ) {//コントローラーボタンが押された際の処理
	// 		const cube = createCube();
  //     cube.position.set(
  //       Math.random() * -1000 - 300,  // x座標を-5から5の範囲でランダムに設定
  //       0,  // y座標
  //       Math.random() * -1000 - 300   // z座標を-5から5の範囲でランダムに設定
  //     );
  //     scene.add(cube);
	// 	} else {
      
	// 	}
	// }
  /* ----コントローラー設定----- */
  

  // 立方体を生成する関数
  function createCube() {
    const geometry = new THREE.BoxGeometry(100,100,100);
    const material = new THREE.MeshBasicMaterial({ color: "red" });//のっぺりとした影が出来ない
    //const material = new THREE.MeshPhongMaterial({ color: getRandomColor() });//光沢感が出る
    //const material = new THREE.MeshStandardMaterial({ color: getRandomColor() });//現実の物理現象を再現する
    const cube = new THREE.Mesh(geometry, material);
    return cube;
  }

  // レンダラーにループ関数を登録
  renderer.setAnimationLoop(tick);
  

      function render() {
  tick();
  handleController( controller1 );
		handleController( controller2 );
  if (!shouldStopRendering) {
    updateTime2();
  }
}

// 初回のレンダリングループの開始
renderer.setAnimationLoop(render);

    </script>
  </body>
</html>
